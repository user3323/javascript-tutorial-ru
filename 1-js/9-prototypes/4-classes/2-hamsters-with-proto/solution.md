# Почему возникает проблема

Давайте подробнее разберем происходящее при вызове `speedy.found("яблоко")`:

1. Интерпретатор ищет свойство `found` в `speedy`. Но `speedy` -- пустой объект, т.к. `new Hamster` ничего не делает с `this`.
2. Интерпретатор идёт по ссылке `speedy.__proto__ (==Hamster.prototype)` и находят там метод `found`, запускает его.
3. Значение `this` устанавливается в объект перед точкой, т.е. в `speedy`.
4. Для выполнения `this.food.push()` нужно найти свойство `this.food`. Оно отсутствует в `speedy`, но есть в `speedy.__proto__`.
5. Значение `"яблоко"` добавляется в `speedy.__proto__.food`.

**У всех хомяков общий живот!** Или, в терминах JavaScript, свойство `food` изменяется в прототипе, который является общим для всех объектов-хомяков.

Заметим, что этой проблемы не было бы при простом присваивании:
// Это присваивание тут вообще не уместно (зачем это писать?)
// Потому что цель (даже исходя из условия) задачи создать МАССИВ (отвечающий за живот)



В этом случае значение записалось бы в сам объект, без поиска `found` в прототипе.
// Как это без поиска "found" в прототипе? Мне кажется, что автор перепутал "food" и "found".
// "found" по-любому будет искаться в прототипе, потому что в самом объекте его не будет, а он нам нужен (исходя из вызова speedy.found("что-то");)

**Проблема возникает только со свойствами-объектами в прототипе.**

Для исправления проблемы нужно дать каждому хомяку свой живот. Это можно сделать, присвоив его в конструкторе.

```js run
function Hamster() {
*!*
  this.food = [];
*/!*
}

Hamster.prototype.found = function(something) {
  this.food.push(something);
};

var speedy = new Hamster();
var lazy = new Hamster();

speedy.found("яблоко");
speedy.found("орех");

alert(speedy.food.length) // 2
alert(lazy.food.length) // 0(!)
```

Теперь всё в порядке. У каждого хомяка -- свой живот.
